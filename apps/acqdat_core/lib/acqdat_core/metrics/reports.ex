defmodule AcqdatCore.Metrics.Reports do
  import Ecto.Query

  alias AcqdatCore.Repo
  alias AcqdatCore.Schema.Metrics
  alias AcqdatCore.Metrics.OrgMetrics

  alias AcqdatCore.Schema.EntityManagement.Organisation

  @moduledoc """
  A module for handling all the organisation related metrics.

  The module handles the core logic to aggregate organisation metrics.
  An organisation has the following artifacts which needs to be tracked:
  - `Projects` See `AcqdatCore.Schema.EntityManagement.Project`
  - `Assets` See `AcqdatCore.Schema.EntityManagement.Asset`
  - `Sensors` See `AcqdatCore.Schema.EntityManagement.Sensor`
  - `AssetTypes` See `AcqdatCore.Schema.EntityManagement.AssetType`
  - `SensorTypes` See `AcqdatCore.Schema.EntityManagement.SensorType`
  - `Gateways` See `AcqdatCore.Schema.IotManager.Gateway`
  - `Active Parameters`
  - `Dashboards` See `AcqdatCore.DashboardManagement.Schema.Dashboard`
  - `Data Insights Fact Tabkes` See See `AcqdatCore.DataInsights.Schema.FactTables`
  - `Data Insights Visualisations` See `AcqdatCore.DataInsights.Schema.Visualizations`

  Other than above entities certain more attrbutes are tracked such as:
  - `Active Parameters`: Number of sensor parameters which are receiving data on a
  daily basis
  - `Reports Download`: Number of reports being donwloaded from the dashboard.

  Other than above parameters there should be a provision to monitor the bandwidth
  and data storage being consumed by an organisation.

  The following entities are logged on a daily basis to keep a track of the
  artifacts being generated by the users of an organisation. The artifacts are
  then aggregated monthly to give an insight into resource usage per organisation.

  ## Algorithm
  The current algorithm checks all the above artifacts being created for an
  organisation and then logs them. The logs are then aggregated every month for
  or uptil the given date to give the trends for a specific month.
  """
  @doc """
  Returns the monthly report for an organisation.

  Expects a month in the integer representation or a date as the input.
  """
  @spec monthly_report(integer(), integer() | String.t()) :: map()
  def monthly_report(org_id, month) when is_integer(month) do
    empty_report = %{
      dashboard_count: 0,
      panel_count: 0,
      widget_count: 0,
      fact_table_count: 0,
      visualisation_count: 0,
      active_parameter_count: 0,
      asset_type_count: 0,
      asset_count: 0,
      gateway_count: 0,
      project_count: 0,
      sensor_type_count: 0,
      sensor_count: 0
    }

    date = DateTime.to_date(DateTime.utc_now())
    date = %{date | month: month}
    start_date = Timex.beginning_of_month(date)
    end_date = Timex.end_of_month(date)
    number_of_days = end_date.day

    query =
      from(
        metric in Metrics,
        where:
          metric.org_id == ^org_id and
            fragment("?::date BETWEEN ? AND ?", metric.inserted_time, ^start_date, ^end_date),
        distinct: fragment("?::date", metric.inserted_time)
      )

    results = Repo.all(query)

    case length(results) != number_of_days do
      true ->
        {:error, "Data missing for organisation on some days, cannot generate report"}

      false ->
        new_report = empty_report

        new_report =
          Enum.reduce(results, new_report, fn daily_report, new_report ->
            new_report = %{
              new_report
              | dashboard_count:
                  new_report.dashboard_count +
                    Map.fetch!(daily_report.metrics.dashboards.dashboards, "count")
            }

            new_report = %{
              new_report
              | panel_count:
                  new_report.panel_count +
                    Map.fetch!(daily_report.metrics.dashboards.panels, "count")
            }

            new_report = %{
              new_report
              | widget_count:
                  new_report.widget_count +
                    Map.fetch!(daily_report.metrics.dashboards.widgets, "count")
            }

            new_report = %{
              new_report
              | fact_table_count:
                  new_report.fact_table_count +
                    Map.fetch!(daily_report.metrics.data_insights.fact_tables, "count")
            }

            new_report = %{
              new_report
              | visualisation_count:
                  new_report.visualisation_count +
                    Map.fetch!(daily_report.metrics.data_insights.visualisations, "count")
            }

            new_report = %{
              new_report
              | active_parameter_count:
                  new_report.active_parameter_count +
                    Map.fetch!(daily_report.metrics.entities.active_parameters, "count")
            }

            new_report = %{
              new_report
              | asset_type_count:
                  new_report.asset_type_count +
                    Map.fetch!(daily_report.metrics.entities.asset_types, "count")
            }

            new_report = %{
              new_report
              | asset_count:
                  new_report.asset_count +
                    Map.fetch!(daily_report.metrics.entities.assets, "count")
            }

            new_report = %{
              new_report
              | gateway_count:
                  new_report.gateway_count +
                    Map.fetch!(daily_report.metrics.entities.gateways, "count")
            }

            new_report = %{
              new_report
              | project_count:
                  new_report.project_count +
                    Map.fetch!(daily_report.metrics.entities.projects, "count")
            }

            new_report = %{
              new_report
              | sensor_type_count:
                  new_report.sensor_type_count +
                    Map.fetch!(daily_report.metrics.entities.sensor_types, "count")
            }

            new_report = %{
              new_report
              | sensor_count:
                  new_report.sensor_count +
                    Map.fetch!(daily_report.metrics.entities.sensors, "count")
            }
          end)

        new_report = %{
          new_report
          | dashboard_count: new_report.dashboard_count / number_of_days
        }

        new_report = %{
          new_report
          | panel_count: new_report.panel_count / number_of_days
        }

        new_report = %{
          new_report
          | widget_count: new_report.widget_count / number_of_days
        }

        new_report = %{
          new_report
          | fact_table_count: new_report.fact_table_count / number_of_days
        }

        new_report = %{
          new_report
          | visualisation_count: new_report.visualisation_count / number_of_days
        }

        new_report = %{
          new_report
          | active_parameter_count: new_report.active_parameter_count / number_of_days
        }

        new_report = %{
          new_report
          | asset_type_count: new_report.asset_type_count / number_of_days
        }

        new_report = %{
          new_report
          | asset_count: new_report.asset_count / number_of_days
        }

        new_report = %{
          new_report
          | gateway_count: new_report.gateway_count / number_of_days
        }

        new_report = %{
          new_report
          | project_count: new_report.project_count / number_of_days
        }

        new_report = %{
          new_report
          | sensor_type_count: new_report.sensor_type_count / number_of_days
        }

        new_report = %{
          new_report
          | sensor_count: new_report.sensor_count / number_of_days
        }

        {:ok, new_report}
    end
  end

  def monthly_report(org_id, end_date) do
    empty_report = %{
      dashboard_count: 0,
      panel_count: 0,
      widget_count: 0,
      fact_table_count: 0,
      visualisation_count: 0,
      active_parameter_count: 0,
      asset_type_count: 0,
      asset_count: 0,
      gateway_count: 0,
      project_count: 0,
      sensor_type_count: 0,
      sensor_count: 0,
      user_count: 0
    }

    start_date = Timex.beginning_of_month(end_date)
    number_of_days = end_date.day

    if(end_date == Timex.today()) do
      daily_report(org_id)
    end

    query =
      from(
        metric in Metrics,
        where:
          metric.org_id == ^org_id and
            fragment("?::date BETWEEN ? AND ?", metric.inserted_time, ^start_date, ^end_date),
        distinct: fragment("?::date", metric.inserted_time)
      )

    results = Repo.all(query)

    case length(results) != number_of_days do
      true ->
        {:error, "Data missing for organisation on some days, cannot generate report"}

      false ->
        new_report = empty_report

        new_report =
          Enum.reduce(results, new_report, fn daily_report, new_report ->
            new_report = %{
              new_report
              | dashboard_count:
                  new_report.dashboard_count +
                    Map.fetch!(daily_report.metrics.dashboards.dashboards, "count")
            }

            new_report = %{
              new_report
              | panel_count:
                  new_report.panel_count +
                    Map.fetch!(daily_report.metrics.dashboards.panels, "count")
            }

            new_report = %{
              new_report
              | widget_count:
                  new_report.widget_count +
                    Map.fetch!(daily_report.metrics.dashboards.widgets, "count")
            }

            new_report = %{
              new_report
              | fact_table_count:
                  new_report.fact_table_count +
                    Map.fetch!(daily_report.metrics.data_insights.fact_tables, "count")
            }

            new_report = %{
              new_report
              | visualisation_count:
                  new_report.visualisation_count +
                    Map.fetch!(daily_report.metrics.data_insights.visualisations, "count")
            }

            new_report = %{
              new_report
              | active_parameter_count:
                  new_report.active_parameter_count +
                    Map.fetch!(daily_report.metrics.entities.active_parameters, "count")
            }

            new_report = %{
              new_report
              | asset_type_count:
                  new_report.asset_type_count +
                    Map.fetch!(daily_report.metrics.entities.asset_types, "count")
            }

            new_report = %{
              new_report
              | asset_count:
                  new_report.asset_count +
                    Map.fetch!(daily_report.metrics.entities.assets, "count")
            }

            new_report = %{
              new_report
              | gateway_count:
                  new_report.gateway_count +
                    Map.fetch!(daily_report.metrics.entities.gateways, "count")
            }

            new_report = %{
              new_report
              | project_count:
                  new_report.project_count +
                    Map.fetch!(daily_report.metrics.entities.projects, "count")
            }

            new_report = %{
              new_report
              | sensor_type_count:
                  new_report.sensor_type_count +
                    Map.fetch!(daily_report.metrics.entities.sensor_types, "count")
            }

            new_report = %{
              new_report
              | sensor_count:
                  new_report.sensor_count +
                    Map.fetch!(daily_report.metrics.entities.sensors, "count")
            }

            new_report = %{
              new_report
              | user_count:
                  new_report.user_count +
                    Map.fetch!(daily_report.metrics.role_manager.users, "count")
            }
          end)

        new_report = %{
          new_report
          | dashboard_count: new_report.dashboard_count / number_of_days
        }

        new_report = %{
          new_report
          | panel_count: new_report.panel_count / number_of_days
        }

        new_report = %{
          new_report
          | widget_count: new_report.widget_count / number_of_days
        }

        new_report = %{
          new_report
          | fact_table_count: new_report.fact_table_count / number_of_days
        }

        new_report = %{
          new_report
          | visualisation_count: new_report.visualisation_count / number_of_days
        }

        new_report = %{
          new_report
          | active_parameter_count: new_report.active_parameter_count / number_of_days
        }

        new_report = %{
          new_report
          | asset_type_count: new_report.asset_type_count / number_of_days
        }

        new_report = %{
          new_report
          | asset_count: new_report.asset_count / number_of_days
        }

        new_report = %{
          new_report
          | gateway_count: new_report.gateway_count / number_of_days
        }

        new_report = %{
          new_report
          | project_count: new_report.project_count / number_of_days
        }

        new_report = %{
          new_report
          | sensor_type_count: new_report.sensor_type_count / number_of_days
        }

        new_report = %{
          new_report
          | sensor_count: new_report.sensor_count / number_of_days
        }

        new_report = %{
          new_report
          | user_count: new_report.user_count / number_of_days
        }

        {:ok, new_report}
    end
  end

  @doc """
  Returns the daily report for an organisation.
  """
  def daily_report(org_id) do
    today = DateTime.to_date(DateTime.utc_now())

    query =
      from(
        org in Organisation,
        where: org.id == ^org_id
      )

    results = Repo.all(query)

    case results == [] do
      true ->
        {:error, "Organisation does not exist"}

      false ->
        query =
          from(
            metric in Metrics,
            where:
              metric.org_id == ^org_id and
                fragment("?::date", metric.inserted_time) == ^today
          )

        results = Repo.all(query)

        if(results == []) do
          OrgMetrics.measure_and_dump()
          daily_report(org_id)
        else
          {:ok, hd(results)}
        end
    end
  end
end
